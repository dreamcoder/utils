{"version":3,"file":"utils.cjs.production.min.js","sources":["../src/math.ts","../src/canned.ts","../src/helpers.ts","../src/typingStatus.ts","../src/debounce.ts","../src/string.ts"],"sourcesContent":["/**\n * Sorts an array of numbers in ascending order.\n * @param {number[]} arr - The array of numbers to be sorted.\n * @returns {number[]} - The sorted array.\n */\nexport function sortAsc(arr: number[]) {\n  // .slice() is used to create a copy of the array so that the original array is not mutated\n  return arr.slice().sort((a, b) => a - b);\n}\n\n/**\n * Calculates the quantile value of an array at a specified percentile.\n * @param {number[]} arr - The array of numbers to calculate the quantile value from.\n * @param {number} q - The percentile to calculate the quantile value for.\n * @returns {number} - The quantile value.\n */\nexport function quantile(arr: number[], q: number) {\n  const sorted = sortAsc(arr); // Sort the array in ascending order\n  return _quantileForSorted(sorted, q); // Calculate the quantile value\n}\n\n/**\n * Clamps a value between a minimum and maximum range.\n * @param {number} min - The minimum range.\n * @param {number} max - The maximum range.\n * @param {number} value - The value to be clamped.\n * @returns {number} - The clamped value.\n */\nexport function clamp(min: number, max: number, value: number) {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\n/**\n * This method assumes the the array provided is already sorted in ascending order.\n * It's a helper method for the quantile method and should not be exported as is.\n *\n * @param {number[]} arr - The array of numbers to calculate the quantile value from.\n * @param {number} q - The percentile to calculate the quantile value for.\n * @returns {number} - The quantile value.\n */\nfunction _quantileForSorted(sorted: number[], q: number) {\n  const clamped = clamp(0, 1, q); // Clamp the percentile between 0 and 1\n  const pos = (sorted.length - 1) * clamped; // Calculate the index of the element at the specified percentile\n  const base = Math.floor(pos); // Find the index of the closest element to the specified percentile\n  const rest = pos - base; // Calculate the decimal value between the closest elements\n\n  // Interpolate the quantile value between the closest elements\n  // Most libraries don't to the interpolation, but I'm just having fun here\n  // also see https://en.wikipedia.org/wiki/Quantile#Estimating_quantiles_from_a_sample\n  if (sorted[base + 1] !== undefined) {\n    // in case the position was a integer, the rest will be 0 and the interpolation will be skipped\n    return sorted[base] + rest * (sorted[base + 1] - sorted[base]);\n  }\n\n  // Return the closest element if there is no interpolation possible\n  return sorted[base];\n}\n\n/**\n * Calculates the quantile values for an array of intervals.\n * @param {number[]} data - The array of numbers to calculate the quantile values from.\n * @param {number[]} intervals - The array of intervals to calculate the quantile values for.\n * @returns {number[]} - The array of quantile values for the intervals.\n */\nexport const getQuantileIntervals = (data: number[], intervals: number[]) => {\n  // Sort the array in ascending order before looping through the intervals.\n  // depending on the size of the array and the number of intervals, this can speed up the process by at least twice\n  // for a random array of 100 numbers and 5 intervals, the speedup is 3x\n  const sorted = sortAsc(data);\n\n  return intervals.map(interval => {\n    return _quantileForSorted(sorted, interval);\n  });\n};\n","import {\n  Conversation,\n  Sender,\n  Variables,\n  CustomAttributes,\n  Contact,\n} from './types/conversation';\nconst MESSAGE_VARIABLES_REGEX = /{{(.*?)}}/g;\n\nconst skipCodeBlocks = (str: string) => str.replace(/```(?:.|\\n)+?```/g, '');\n\nexport const capitalizeName = (name: string | null) => {\n  return (name || '').replace(/\\b(\\w)/g, s => s.toUpperCase());\n};\n\nexport const getFirstName = ({ user }: { user: Sender }) => {\n  const firstName = user?.name ? user.name.split(' ').shift() : '';\n  return capitalizeName(firstName as string);\n};\n\nexport const getLastName = ({ user }: { user: Sender }) => {\n  if (user && user.name) {\n    const lastName =\n      user.name.split(' ').length > 1 ? user.name.split(' ').pop() : '';\n    return capitalizeName(lastName as string);\n  }\n  return '';\n};\n\nexport const getMessageVariables = ({\n  conversation,\n  contact,\n}: {\n  conversation: Conversation;\n  contact?: Contact;\n}) => {\n  const {\n    meta: { assignee, sender },\n    id,\n    custom_attributes: conversationCustomAttributes = {},\n  } = conversation;\n  const { custom_attributes: contactCustomAttributes } = contact || {};\n\n  const standardVariables = {\n    'contact.name': capitalizeName(sender?.name || ''),\n    'contact.first_name': getFirstName({ user: sender }),\n    'contact.last_name': getLastName({ user: sender }),\n    'contact.email': sender?.email,\n    'contact.phone': sender?.phone_number,\n    'contact.id': sender?.id,\n    'conversation.id': id,\n    'agent.name': capitalizeName(assignee?.name || ''),\n    'agent.first_name': getFirstName({ user: assignee }),\n    'agent.last_name': getLastName({ user: assignee }),\n    'agent.email': assignee?.email ?? '',\n  };\n  const conversationCustomAttributeVariables = Object.entries(\n    conversationCustomAttributes as CustomAttributes\n  ).reduce((acc: CustomAttributes, [key, value]) => {\n    acc[`conversation.custom_attribute.${key}`] = value;\n    return acc;\n  }, {});\n\n  const contactCustomAttributeVariables = Object.entries(\n    contactCustomAttributes as CustomAttributes\n  ).reduce((acc: CustomAttributes, [key, value]) => {\n    acc[`contact.custom_attribute.${key}`] = value;\n    return acc;\n  }, {});\n\n  const variables = {\n    ...standardVariables,\n    ...conversationCustomAttributeVariables,\n    ...contactCustomAttributeVariables,\n  };\n\n  return variables;\n};\n\nexport const replaceVariablesInMessage = ({\n  message,\n  variables,\n}: {\n  message: string;\n  variables: Variables;\n}) => {\n  // @ts-ignore\n  return message?.replace(MESSAGE_VARIABLES_REGEX, (_, replace) => {\n    return variables[replace.trim()]\n      ? variables[replace.trim().toLowerCase()]\n      : '';\n  });\n};\n\nexport const getUndefinedVariablesInMessage = ({\n  message,\n  variables,\n}: {\n  message: string;\n  variables: Variables;\n}) => {\n  const messageWithOutCodeBlocks = skipCodeBlocks(message);\n  const matches = messageWithOutCodeBlocks.match(MESSAGE_VARIABLES_REGEX);\n  if (!matches) return [];\n\n  return matches\n    .map(match => {\n      return match\n        .replace('{{', '')\n        .replace('}}', '')\n        .trim();\n    })\n    .filter(variable => {\n      return variables[variable] === undefined;\n    });\n};\n","import isToday from 'date-fns/isToday';\nimport isYesterday from 'date-fns/isYesterday';\n/**\n * @name Get contrasting text color\n * @description Get contrasting text color from a text color\n * @param bgColor  Background color of text.\n * @returns contrasting text color\n */\nexport const getContrastingTextColor = (bgColor: string): string => {\n  const color = bgColor.replace('#', '');\n  const r = parseInt(color.slice(0, 2), 16);\n  const g = parseInt(color.slice(2, 4), 16);\n  const b = parseInt(color.slice(4, 6), 16);\n  // http://stackoverflow.com/a/3943023/112731\n  return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#FFFFFF';\n};\n\n/**\n * @name Get formatted date\n * @description Get date in today, yesterday or any other date format\n * @param date  date\n * @param todayText  Today text\n * @param yesterdayText  Yesterday text\n * @returns formatted date\n */\nexport const formatDate = ({\n  date,\n  todayText,\n  yesterdayText,\n}: {\n  date: string;\n  todayText: string;\n  yesterdayText: string;\n}) => {\n  const dateValue = new Date(date);\n  if (isToday(dateValue)) return todayText;\n  if (isYesterday(dateValue)) return yesterdayText;\n  return date;\n};\n\n/**\n * @name formatTime\n * @description Format time to Hour, Minute and Second\n * @param timeInSeconds  number\n * @returns formatted time\n */\n\nexport const formatTime = (timeInSeconds: number) => {\n  let formattedTime = '';\n  if (timeInSeconds >= 60 && timeInSeconds < 3600) {\n    const minutes = Math.floor(timeInSeconds / 60);\n    formattedTime = `${minutes} Min`;\n    const seconds = minutes === 60 ? 0 : Math.floor(timeInSeconds % 60);\n    return formattedTime + `${seconds > 0 ? ' ' + seconds + ' Sec' : ''}`;\n  }\n  if (timeInSeconds >= 3600 && timeInSeconds < 86400) {\n    const hours = Math.floor(timeInSeconds / 3600);\n    formattedTime = `${hours} Hr`;\n    const minutes =\n      timeInSeconds % 3600 < 60 || hours === 24\n        ? 0\n        : Math.floor((timeInSeconds % 3600) / 60);\n    return formattedTime + `${minutes > 0 ? ' ' + minutes + ' Min' : ''}`;\n  }\n  if (timeInSeconds >= 86400) {\n    const days = Math.floor(timeInSeconds / 86400);\n    formattedTime = `${days} Day`;\n    const hours =\n      timeInSeconds % 86400 < 3600 || days >= 364\n        ? 0\n        : Math.floor((timeInSeconds % 86400) / 3600);\n    return formattedTime + `${hours > 0 ? ' ' + hours + ' Hr' : ''}`;\n  }\n  return `${Math.floor(timeInSeconds)} Sec`;\n};\n\n/**\n * @name trimContent\n * @description Trim a string to max length\n * @param content String to trim\n * @param maxLength Length of the string to trim, default 1024\n * @param ellipsis Boolean to add dots at the end of the string, default false\n * @returns trimmed string\n */\nexport const trimContent = (\n  content: string = '',\n  maxLength: number = 1024,\n  ellipsis: boolean = false\n) => {\n  let trimmedContent = content;\n  if (content.length > maxLength) {\n    trimmedContent = content.substring(0, maxLength);\n  }\n  if (ellipsis) {\n    trimmedContent = trimmedContent + '...';\n  }\n  return trimmedContent;\n};\n\n/**\n * @name convertSecondsToTimeUnit\n * @description Convert seconds to time unit\n * @param seconds  number\n * @param unitNames  object\n * @returns time and unit\n * @example\n * convertToUnit(60, { minute: 'm', hour: 'h', day: 'd' }); // { time: 1, unit: 'm' }\n * convertToUnit(60, { minute: 'Minutes', hour: 'Hours', day: 'Days' }); // { time: 1, unit: 'Minutes' }\n */\n\nexport const convertSecondsToTimeUnit = (\n  seconds: number,\n  unitNames: { minute: string; hour: string; day: string }\n) => {\n  if (seconds === null || seconds === 0)\n    return { time: null, unit: unitNames.minute };\n  if (seconds < 3600)\n    return { time: Number((seconds / 60).toFixed(1)), unit: unitNames.minute };\n  if (seconds < 86400)\n    return { time: Number((seconds / 3600).toFixed(1)), unit: unitNames.hour };\n  return { time: Number((seconds / 86400).toFixed(1)), unit: unitNames.day };\n};\n","/**\n * Creates a typing indicator utility.\n * @param onStartTyping Callback function to be called when typing starts\n * @param onStopTyping Callback function to be called when typing stops after delay\n * @param idleTime Delay for idle time in ms before considering typing stopped\n * @returns An object with start and stop methods for typing indicator\n */\n\ntype CallbackFunction = () => void;\ntype Timeout = ReturnType<typeof setTimeout>;\n\nexport const createTypingIndicator = (\n  onStartTyping: CallbackFunction,\n  onStopTyping: CallbackFunction,\n  idleTime: number\n) => {\n  let timer: Timeout | null = null;\n\n  const start = (): void => {\n    if (!timer) {\n      onStartTyping();\n    }\n    reset();\n  };\n\n  const stop = (): void => {\n    if (timer) {\n      clearTimeout(timer as Timeout);\n      timer = null;\n      onStopTyping();\n    }\n  };\n\n  const reset = (): void => {\n    if (timer) {\n      clearTimeout(timer as Timeout);\n    }\n    timer = setTimeout(() => {\n      stop();\n    }, idleTime) as Timeout;\n  };\n\n  return { start, stop };\n};\n","// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\n/**\n * @func Callback function to be called after delay\n * @delay Delay for debounce in ms\n * @immediate should execute immediately\n * @returns debounced callback function\n */\nexport const debounce = (\n  func: (args: any) => void,\n  wait: number,\n  immediate?: boolean\n) => {\n  let timeout: number | undefined | null;\n\n  return function() {\n    const context = null;\n    const args = arguments;\n    const later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args as any);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout as number);\n    timeout = window.setTimeout(later, wait);\n    if (callNow) func.apply(context, args as any);\n  };\n};\n","/**\n * Function that parses a string boolean value and returns the corresponding boolean value\n * @param {string | number} candidate - The string boolean value to be parsed\n * @return {boolean} - The parsed boolean value\n */\n\nexport function parseBoolean(candidate: string | number) {\n  try {\n    // lowercase the string, so TRUE becomes true\n    const candidateString = String(candidate).toLowerCase();\n\n    // wrap in boolean to ensure that the return value\n    // is a boolean even if values like 0 or 1 are passed\n    return Boolean(JSON.parse(candidateString));\n  } catch (error) {\n    return false;\n  }\n}\n"],"names":["sortAsc","arr","slice","sort","a","b","clamp","min","max","value","_quantileForSorted","sorted","q","clamped","pos","length","base","Math","floor","undefined","MESSAGE_VARIABLES_REGEX","capitalizeName","name","replace","s","toUpperCase","getFirstName","user","firstName","split","shift","getLastName","lastName","pop","seconds","unitNames","time","unit","minute","Number","toFixed","hour","day","onStartTyping","onStopTyping","idleTime","timer","stop","clearTimeout","start","setTimeout","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","window","date","todayText","yesterdayText","dateValue","Date","isToday","isYesterday","timeInSeconds","formattedTime","minutes","hours","days","bgColor","color","parseInt","conversation","meta","assignee","sender","id","custom_attributes","conversationCustomAttributes","contactCustomAttributes","contact","email","phone_number","Object","entries","reduce","acc","data","intervals","map","interval","variables","matches","message","match","trim","filter","variable","candidate","candidateString","String","toLowerCase","Boolean","JSON","parse","error","_","content","maxLength","ellipsis","trimmedContent","substring"],"mappings":"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"}